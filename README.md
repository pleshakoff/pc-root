# Parents committee 
[Russian version](https://github.com/pleshakoff/pc-root/blob/master/README_RUS.md)

1. [System Description](#desc)
2. [Logical structure](#struct)
3. [Services](#service)
4. [Monitoring](#monitoring)
5. [Get started](#get-started)
6. [Realtime notifications](#hw5)
7. [Caching](#hw6)
8. [Asynchronous interaction](#hw7)


<a name="desc"></a>
## System description. 
The system is designed to automate the work of the parent committee at school or kindergarten.

##### Available functionality at the present time: 

* Authorization and authentication. 
* Registration of the class and educational institution
* Managing the student list
* Registration of parents and linking to students
* Publishing and reading news
* Sending notifications to parents of students
* Conducting polls among parents

##### Planned functionality: 

* Accounting for fundraising and purchases

Work in the system for each user is carried out within the workspace (group or class).
 
Users can be of three types: 
* Administrator 
* Member of the parent committee 
* Parent

You need to create your own group and invite other users there to organize a parent committee in the system.
The user who created the group becomes the "Administrator" and can invite other members of the parent committee or just parents.
Other users can join only after receiving an invitation from the administrator or from a member of the parent committee.

At the moment, in order to register as a member of the parent committee, it is 
enough to know the class ID.
In order to register as a parent, you need to know the student ID.

The same user can be a member of several groups.  

Members of the parent committee form a list of students within the group. 
Countless users can be linked to one student.
A user can be a parent of several students from the same group or from different groups.

When entering or in the process of work, the user should select the current student from the list available to him, 
on whose behalf he performs operations.
 
Only members of the parent committee see the entire list of class students.
An ordinary parent can only see his children. 

Members of the parent committee can publish news. 
Ordinary users have access to the news feed. 
When news is published, notifications are sent to all users (parents)

Members of the parent committee can create a poll. While the request is active, parents can choose one of the answers, 
or change their option. After the poll is closed, nothing can be changed. 
The poll can be both group-wide, in which all students of the group participate, 
and for a limited list of students.
Each parent can vote for the student he is linked to. If several parents are linked to a student, 
then both can change the result, but only for their child.
Polls can be public and anonymous. 
Notifications are sent when creating a poll. 

The system introduces the concept of "Goal" to manage the finances of the parent committee. 
Within the framework of goal, the required amount and the list of students who participate in achieving the goal are set. 
For example, everyone should bring money for the "class needs" goal, and only a part of the students should bring money for the "excursion" goal.
Within the framework of goal, incoming payments from students and outgoing ones are taken into account with a description of what was spent and an attachment of the receipt.
A member of the parent committee enters data on receipts and expenses and sees all the movement for all goals. 
Ordinary parents see the goals available to them, the total amount of the goal and expenses.
Reports are available for members of the parent committee: lists of debtors, period expenses, etc.
When forming a new goal, notifications are sent to parents of children.  
            

<a name="struct"></a>
## Logical structure 


![alt text](https://github.com/pleshakoff/pc-root/blob/master/pics/parcom_eng.png?raw=true"")


All services work in the context of the current student. The data about the user's current student is 
encrypted in a "self contained" token, 
which is generated by the authorization service [Security](#Security) and should be passed to all requests to services.

The token is validated on the services side (sidecar).  

Authorization is also on the services side, by defining access to methods for a role from a token 
(a user can have only one role and it can be transferred in a token)

Service [Money](#Money) is on the diagram, but it is not implemented. 

<a name="service"></a>
## Services

* [Security](#Security)
* [Classroom](#Classroom)
* [News](#News)
* [Polls](#Polls)
* [Money](#Money)
* [Notifier](#Notifier)
* [Notifier Agent Email](#NotifierAgentEmail)
* [Notifier Agent Push](#NotifierAgentPush)
* [Notifier Agent Websocket](#NotifierAgentWebsocket)
* [User cache](#UserCache)

<a name="Security"></a>
### Security 

Repository: https://github.com/pleshakoff/pc-security 
Swagger: http://localhost:8081/api/v1/swagger-ui.html

Account Management Service 

* Registration and account storage 
* Authentication 
* Creation of a "self contained" token with an expiration date.
* Storing and switching the current student and user group
* Password change 
* Registration confirmation (not implemented) 


#### Interaction with other services 

1. When changing the current student or group (/auth/context) in which the work is planned,
the methods of the service are called [Classroom](#Classroom) 
to check whether the user is linked to a group (GET /group/my) or a student (GET/students/my).
 
 2. The account registration (POST /users/register) and deletion (DELETE /users/{id}) methods 
cannot be called directly, because the account is linked to the parent who is registered in the service
 [Classroom](#Classroom).  An error doesn't occurs if only they are called from the service [Classroom](#Classroom)   
 

<a name="Classroom"></a>
### Classroom 

Repository: https://github.com/pleshakoff/pc-classroom 

Swagger: http://localhost:8080/api/v1/swagger-ui.html

The service is responsible for managing the parent committee workspace. 
And for the relationship of the main participants of the business process.   

* Group/class registration
* Managing the student list
* Registration of parents 
* Linking parents to students

#### Interaction with other services 

1. After registering a new group (POST/add/group), a parent committee member (POST/add/member) 
or an ordinary parent (POST/add/parent) the registering method of a new service account is called
 [Security](#Security) (POST /users/register). If the call fails, the creation of a new parent or group is rolled back.   
 
 2. When deleting a user (parent) (DELETE /users/{id}) the delete method is called (DELETE /users/{id}) of the 
service account [Security](#Security) (DELETE /users/{id}). If the call fails, the deletion is rolled back.  
 
 3. Is a provider of information about the list of students. 
 When deleting or adding a student, it sends a message to the message broker for synchronization
 with lists of students in service consumer. 
 
 4. When updating the parent's data, the cache service method is called [User cache](#UserCache), resetting
    cache data for the changed user (DELETE /users/reset/{id})
)
 

<a name="News"></a>
### News  
Repository: https://github.com/pleshakoff/pc-classroom 

Swagger: http://localhost:8082/api/v1/swagger-ui.html

The service responsible for working with news. 
At the moment, it allows users to publish and read news in the group context.
It can potentially aggregate news from other sources and show them to parents. 

* Publishing and storing news
* Getting a list of news 
* News discussion (not implemented)

#### Interaction with other services
 
 1. When publishing a news (POST/news), a message is sended to the broker, which is processed by the service 
[Notifier](#Notifier), which sends a group message to the agents. 
 The news is published regardless of whether the notification was sent successfully.   
 2. Receiving a signal via a message broker about the deleting a group from the service [Classroom](#Classroom)  


<a name="Polls"></a>
### Polls  


The service is designed to conduct polls among the parents of the group.

* Creating a poll 
* Selecting students for the poll 
* Voting

#### Interaction with other services 

1. When creating a poll, if it is group-wide, the current composition of the group is requested from the service [Classroom] (#Classroom), 
and the list of students is linked to the poll. 
 
 2. The list of students in active polls is synchronized with the list of 
group students provided by the service [Classroom](#Classroom) via the message broker. If there is a new student in the group, 
then he is added to the active group-wide polls. If a student is deleted, then he is deleted from any active 
polls.
 
3. Receiving a signal via a message broker about the deleting a group from the service [Classroom](#Classroom). 
    
4. When publishing a poll, a message is placed in the broker, which is processed
    by the service [Notifier](#Notifier), which sends a group-wide message
    or a message to a limited list of users, poll participants via agents. 
 

<a name="Money"></a>
### Money  

**NOT IMPLEMENTED**

Group cash accounting service 

* Managing fundraising goals 
* Accounting for incoming transactions 
* Accounting for outgoing transactions
* Queres for reports (balances, debtors)
 
#### Interaction with other services 

1. When creating a fundraising goal, if it is group-wide, the 
current composition of the group and the list of students is linked to the goal is requested from the service [Classroom](#Classroom). 
 
 2. The list of students in active fundraising is synchronized with the list of 
group students provided by the service [Classroom](#Classroom)via the message broker. If there is a new student in the group, 
then he is added to the active group-wide fundraising. If a student is deleted, then he is deleted from any active 
fundraising.
 
 3. Receiving a signal via a message broker about the deleting a group from the service [Classroom](#Classroom). 

 4. When creating a fundraising goal, a message is placed in the broker, which is processed by the service 
[Notifier](#Notifier), which sends a group message or message to a list of users 
participanting in the fundraising via agents. 


<a name="Notifier"></a>
### Notifier  

Repository: https://github.com/pleshakoff/pc-notifier 

Swagger: http://localhost:8083/api/v1/swagger-ui.html

The service is responsible for generating a list of notification recipients and sending notifications via the broker to agents. 

Supports three types of notifications 

* For the whole group. 
* For an individual user 
* For a list of users

Depending on the type of notification, it generates a list of recipient users 
and sends a message for each recipient in the message broker.   

#### Interaction with other services 

1. If the message is group-wide (POST/send/group), then it requests the IDs of group users (parents)
at the service [Classroom](#Classroom) (GET /users/all)
 
2. Adds messages to the queue in the message broker from which it is processed by subscribed agents. 

<a name="NotifierAgentEmail"></a>
### Notifier Agent Email    

Repository: https://github.com/pleshakoff/pc-notifier-agent-email 

Swagger: http://localhost:8084/api/v1/swagger-ui.html

Sending an email to the user. 

#### Interaction with other services 

1. Receives the user ID and message text from the service [Notifier](#Notifier) via the broker, 
2. Requests the user's email from the service with cached user data [User cache](#UserCache) (GET /users/{id}) 
and sends an email (in current version it just writes into log) 

<a name="NotifierAgentPush"></a>
### Notifier Agent Push

Repository: https://github.com/pleshakoff/pc-notifier-agent-push 

Swagger: http://localhost:8085/api/v1/swagger-ui.html

#### Interaction with other services 

1. Receives the user ID and message text from the service [Notifier](#Notifier) via the broker 
2. Requests the user's phone number from the service with cached user data [User cache](#UserCache) 
(GET /users/{id}) and sends sms (in current version it just writes into log) 


<a name="NotifierAgentWebsocket"></a>
### Notifier Agent Websocket

Repository: https://github.com/pleshakoff/pc-notifier-agent-websocket 

Swagger: http://localhost:8087/api/v1/swagger-ui.html

Agent for sending realtime notifications to clients via websocket

The client application can connect to the socket and subscribe to receive notifications.

Endpoint to connect to socket `/pusher`
Endpoint for notification subscription `/topic/notifications/{idUser}`

An unauthorized user can create a websocket connection. 
After the connection setup, he should subscribe to socket. When subscribing, it is necessary to 
specify a jwt token in the header of the stomp message. If this is not done, the server will terminate the session by timeout. 


#### Interaction with other services 

1. Receives the user ID and message text from the service [Notifier](#Notifier) via a queue in the broker


<a name="UserCache"></a>
### User cache

Repository: https://github.com/pleshakoff/pc-user-cache 

Swagger: http://localhost:8086/api/v1/swagger-ui.html

A service for caching data of parents (users). 
The cache is reset after the ttl expires or when the parent (user) data changes in the service [Classroom](#Classroom) 

#### Interaction with other services 

1. Requests user data from the service [Classroom](#Classroom) (GET /users/{id}) if the data is not found in cache 
2. Resets user data when other services call a special endpoint (DELETE /users/reset/{id}) 


<a name="monitoring"></a>
## Monitoring

Endpoints are created in all services to collect metrics about the state of the process. 
**Prometheus** collects and stores metrics. 
**Grafana** is used as a dashboard. 

Access to Grafana http://localhost:3000/login:admin 

pass:admin

The database already has a preconfigured dashboard: **PARCOM**.  You can select an instance on it and view its metrics. 

![alt text](https://github.com/pleshakoff/pc-root/blob/master/pics/parcom_hw7_dashboard.png?raw=true"")
 


<a name="get-started"></a>
## Get started 

To deploy services, you need to run `docker-compose up` from this repository, 
service containers will be pulled from the public docker hub.

Test data is loaded into the system and you can try to call the API. 
Links to swagger for each service are provided in the description of the services. 

### Login

Now there are three users with different roles created in the system, you can log in with one of them, 
or immediately use a ready-made test token 
http://localhost:8081/api/v1/auth/login 

**Admin** 

logn: admin@mail.com 

pass: 12345 

token: eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbkBtYWlsLmNvbSIsInVzZXIiOiJhZG1pbkBtYWlsLmNvbSIsImlkVXNlciI6MSwiaWRHcm91cCI6MjEsImlkU3R1ZGVudCI6MzEsImF1dGhvcml0aWVzIjoiUk9MRV9BRE1JTiIsImlhdCI6MTU3NjMyMDc5NywiZXhwIjoxNjA3ODU2Nzk3fQ.qEfk5Jxdc7lNpJq_AF5gjn985FZMHhnHYNroM2Thu7kVz04OucBSEWcT0dKRHytWXmr6IsVX28BuNZEfN0Z8zg


**Parent committee member** 

logn: molly@weasley.com 

pass: 12345 

token: eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJtb2xseUB3ZWFzbGV5LmNvbSIsInVzZXIiOiJtb2xseUB3ZWFzbGV5LmNvbSIsImlkVXNlciI6MiwiaWRHcm91cCI6MjEsImlkU3R1ZGVudCI6MzIsImF1dGhvcml0aWVzIjoiUk9MRV9NRU1CRVIiLCJpYXQiOjE1NzYzMjA3NDEsImV4cCI6MTYwNzg1Njc0MX0.lo9iJNR3XW-R8EzQKivIKEJD0nwvFAoIyT62lE2f3PvC6oP66jHDloC83wukTEcemmuI_Ant4bq1t4EF-r7WGg


**Ordinary parent** 

logn: artur@weasley.com 

pass: 12345 

token: eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhcnR1ckB3ZWFzbGV5LmNvbSIsInVzZXIiOiJhcnR1ckB3ZWFzbGV5LmNvbSIsImlkVXNlciI6MywiaWRHcm91cCI6MjEsImlkU3R1ZGVudCI6MzIsImF1dGhvcml0aWVzIjoiUk9MRV9QQVJFTlQiLCJpYXQiOjE1NzYzMjA2ODgsImV4cCI6MTYwNzg1NjY4OH0.E91aUr4OKnWq1sdRVpSdv2UDuis9i5-9QUMgQxn_I4iNB7ee5so04gzisJGL9a3UhNLHTjwu3yN-AVEWVZ8w-Q
 
### Registration

Registration via the service [Classroom](#Classroom). 
In addition to the account, a parent is created during registration and is linked to the group and to the student.

Student or group data is required for registration. 
It is assumed that the invitation letters 
with the necessary encrypted information were sent to the parents and they register by following the link in the letter.
Sending invitations has not yet been implemented.  
 
**Registration of an ordinary parent** 
http://localhost:8080/api/v1/add/parent

It is necessary to know the student ID.

`{
  "email": "parent@mail.ru",
  "idStudent": 31,
  "password": "12345",
  "passwordConfirm": "12345"
}
`

**Registration of a parent committee member** 
http://localhost:8080/api/v1/add/member

You need to know the group id.  You can specify the student id. 

`{
  "email": "member@mail.ru",
  "idGroup": 21,
  "idStudent": 31,
  "password": "12345",
  "passwordConfirm": "12345"
}
`

**Registration of a new group and admin** 
http://localhost:8080/api/v1/add/group

Admin is the creator of the group.
 
You can select a school from existing ones 

`{
"email": "creator@mail.ru ",
"nameGroup": "1A",
"idSchool": "11",
"password": "12345",
"passwordConfirm": "12345"
}
`

or create your own

`{
"email": "creator@mail.ru",
"nameGroup": "1A",
"nameSchool": "School No. 777",
"password": "12345",
"passwordConfirm": "12345"
}
`

After registration, you can authenticate using email as a login 


<a name="hw5"></a>
## Realtime 


Realtime notifications are implemented via websocket. The service 
[Notifier Agent Websocket](#NotifierAgentWebsocket) is responsible for sending notifications  

To deploy services, you need to run `docker-compose up` from this repository, 
service containers will be launched from the public docker hub. (see [Get started](#get-started))
 
To test the connection to websocket and subscribe to notifications, you need to take a 
demo client web application from the current repository. 
It is located in the `websocket_demo` folder, download the content folder and open `websocket_demo/index.html ` 
in the browser. 

Press the "Connect" button to connect to the socket. And send the news via the service[News](#News). 
How to do this is described in detail [here](#hw6addNews)

The publication of the news launches a mechanism for sending notifications to all parents of the group. 
Service [Notifier](#Notifier) receives a list of parents and puts a message for each parent in a 
queue, from where it is processed by various agents, including [Notifier Agent Websocket](#NotifierAgentWebsocket), 
which sends messages to clients connected to its socket.    

As a result, a notification about the published news should appear in the notification table on the demo page

![alt text](https://github.com/pleshakoff/pc-root/blob/master/screen/wsDemo_hw8.png?raw=true"")

You can see the implementation of the connection here `websocket_demo/js/app.js `
Well, or here https://github.com/pleshakoff/pc-root/blob/master/websocket_demo/js/app.js 

All settings for the demonstration are hard-coded directly in the java script.
 
Is is assumed that the client is logged in, has already received an authorization jwt token and knows the current user ID.
On our demo page, we are subscribed to notifications for a user with ID 1, this is one of the parents of the group.
Although push notifications are sent to three users at once, only one is online. 

Authorization is organized as follows. An unauthorized user can create a websocket connection. 
After the connection setup, he should subscribe to mailing. When subscribing, you must 
specify a token in the header of the stomp message. If this is not done, the server will terminate the session (I have set a timeout of 2 seconds so far). 

It is implemented on the server as follows. During a handshake, a session is created and placed in the list of sessions 
waiting for confirmation. For each session, the time before which it needs to be confirmed is fixed.
If the subscription occured and the token was correct, then the session is removed from the list and is considered confirmed. 
If not, it will be killed by a background process that monitors the list for "expired" sessions.    

![alt text](https://github.com/pleshakoff/pc-root/blob/master/screen/log1hw8.1.png?raw=true"")          


<a name="hw6"></a>
## Caching

The data of users (parents) is selected as the object for caching. 
Firstly, this data are stable and rarely change. 
Secondly, one of the most frequent operations in the system is sending notifications that require user data.
Notifications are sent when news, comments, polls, fundraising starts, etc. are added.
Notifications are sent by agents, each of which is responsible for various notification methods: email, SMS, 
message in popular social networks, and so on. 
Each agent is autonomous and each of them needs different user data. 
Each agent requests the profile of the recipient user from the service [Classroom](#Classroom) and uses the data 
that it needs to generate and send notifications (for example, e-mail and name to send an email, and phone number to send sms). 
If one agent requested user profile data, it is logical to save this data somewhere 
so that the agent sending notifications in another way can use them. 
Also, when sending the next notification to the same user, you can take them from the cache again. 

The cache is located in the service [User cache](#UserCache) 
Redis is used as cache store.  
Time to live selected: 10 minutes. 
Also when changing user data in the service [Classroom](#Classroom), a message is sent to the cache service [User cache](#UserCache) 
and the cache for the changed user is reset
 
As the amount of data grows, the cache can be partitioned, for example, by geography, 
depending on the region in which the educational institution is located
 
In order to check the cache operation, you need to add news, and notifications will be sent to all parents of the group.
After that, you need to check the caching service logs. 

To deploy services, you need to run `docker-compose up` from this repository, 
service containers will be launched from the public docker hub. (see [Get started](#get-started))
 
<a name="hw6addNews"></a>
##### Add news:


Service[News](#News) Swagger: http://localhost:8082/api/v1/swagger-ui.html

Controller `/news` method `POST`

A test eternal token for authorization. It is necessary to add to the request header (X-Auth-Token) 
`eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbkBtYWlsLmNvbSIsInVzZXIiOiJhZG1pbkBtYWlsLmNvbSIsImlkVXNlciI6MSwiaWRHcm91cCI6MjEsImlkU3R1ZGVudCI6MzEsImF1dGhvcml0aWVzIjoiUk9MRV9BRE1JTiIsImlhdCI6MTU3NjMyMDc5NywiZXhwIjoxNjA3ODU2Nzk3fQ.qEfk5Jxdc7lNpJq_AF5gjn985FZMHhnHYNroM2Thu7kVz04OucBSEWcT0dKRHytWXmr6IsVX28BuNZEfN0Z8zg`

Request body 

`
{
 "title": "Attention! Important message!", 
"message": "Parents are required to participate in voluntary sack races. The volunteers are expected to attend"
}
`

After the news is published, a notification will be sent to the service [Notifier](#Notifier), 
which will redirect it to three agents

##### View logs

`docker-compose logs pc-user-cache`

It seems that when accessing the service [User cache](#UserCache) of the first agent, the 
call is redirected to the service [Classroom](#Classroom). 
When the second agent tries to get the data of the same user, the data is already taken from the cache.  

Something like this: 

![alt text](https://github.com/pleshakoff/pc-root/blob/master/screen/log1hw5.png?raw=true"")

Now you can update the data of one of the users

Service [Classroom](#Classroom) Swagger: http://localhost:8080/api/v1/swagger-ui.html

Controller `/users/1` method `PUT`

A test eternal token for authorization. It is necessary to add to the request header (X-Auth-Token) 
`eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbkBtYWlsLmNvbSIsInVzZXIiOiJhZG1pbkBtYWlsLmNvbSIsImlkVXNlciI6MSwiaWRHcm91cCI6MjEsImlkU3R1ZGVudCI6MzEsImF1dGhvcml0aWVzIjoiUk9MRV9BRE1JTiIsImlhdCI6MTU3NjMyMDc5NywiZXhwIjoxNjA3ODU2Nzk3fQ.qEfk5Jxdc7lNpJq_AF5gjn985FZMHhnHYNroM2Thu7kVz04OucBSEWcT0dKRHytWXmr6IsVX28BuNZEfN0Z8zg`

Request body 

`
{ 
"familyName": "Last Name", 
"firstName": "First name", 
"middleName": "Middle name",
  "phone": "+7 915 1234567"
}
`

The cache for the user with ID 1 will be reset. 

If you post another news and view the log, you can see that the data for the first user has been reset, and the data of the rest is taken from the cache

![alt text](https://github.com/pleshakoff/pc-root/blob/master/screen/log2hw5.png?raw=true"")

<a name="hw7"></a>
## Asynchronous interaction

Kafka message broker is added.  

Why did I choose it?

I chose between RabbitMQ and Kafka 

1) This system does not need RabbitMQ's smart message routing capabilities. 
Indeed, we need facts that something has been updated somewhere, 
and consumers need to decide what to do with it (dumb broker).
2) The chosen architecture assumes that there are some sources of knowledge, for 
example, the membership of a group of students and there are a number of consumers of the fact of a change in group membership. 
In the case of RabbitMQ, the message about the group membership change should be routed in several queues. 
Each subscriber service has its own queue. If another service is added that needs the group membership, 
it will be necessary to reconfigure the broker
In the case of Kafka, all services read from the same topic, just different offset for different groups.
3) The same with sending notifications to users. Several agents can be subscribed to one topic. 
When an agent is added, it's just another subscriber, nothing needs to be changed.  
4) One of the advantages of Kafka is that it is more resistant to loads and scales better. 
When using this system, seasonal loads are assumed (September and the beginning of studies). 
At such moments, you can increase the number of partitions in the topic and the number of subscriber instances.
 

The following operations are now performed using the message-based protocol 

1) Sending notifications by services 
2) Sending notification to subscribed agents 
3) Message to the subscriber services about the change in the group membership (deleting, adding of a student) 
4) A message about deleting a group.  


To deploy services, you need to run`docker-compose up` from this repository, 
service containers will be launched from the public docker hub. (see [Get started](#get-started))

In order to check the performance, it is necessary to add the news 
as it is described in [homework #6](#hw6addNews)

After that, you can view the logs of the service [Notifier](#Notifier), which takes a message from the queue, 
determines the list of recipients and places a notification for each recipient in the queue 
to which agents are subscribed: [Notifier Agent Email](#NotifierAgentEmail), [Notifier Agent Push](#NotifierAgentPush) and
[Notifier Agent Websocket](#NotifierAgentWebsocket)


[Notifier](#Notifier)
![alt text](https://github.com/pleshakoff/pc-root/blob/master/screen/log1hw6.png?raw=true"")

[Notifier Agent Email](#NotifierAgentEmail)
![alt text](https://github.com/pleshakoff/pc-root/blob/master/screen/log2hw6.png?raw=true"")
  

 

  

